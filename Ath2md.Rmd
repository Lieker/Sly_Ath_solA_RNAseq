---
title: "Ath2"
output: html_document
date: "April 20th 2021"
author: "Lieke Vlaar"
---

# Introduction
In this file the complete analysis workflow of count data of the Arabidopsis RNAseq experiment is shown.

## Goal

The goal of this experiment is to unravel the effect of solanoeclepin A on the plant. Solanoeclepin A is applied on Arabidopsis seedlings under various nutritional conditions. The set up of this experiment is summarized in this figure:
```{r include = FALSE}
if ("knitr" %in% installed.packages()){
  library("knitr")
} else {
  install.packages("knitr")
  library("knitr")
}
```
```{r setup, include = FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

```{r figurename, echo=FALSE, out.width = '90%'}
knitr::include_graphics("Ath2/image.png")
```

## Setup

Packages necessary:

* Checkpoint
* DESeq2
* dplyr
* tidyr
* tidyverse
* Biostrings
* biomaRt
* biomartr
* clusterProfiler
* org.At.tair.db
* tibble
* mixOmics
* vegan
* apeglm
* EnhancedVolcano
* patchwork

```{r include=FALSE}
#########
# Library
#########
if ("checkpoint" %in% installed.packages()){
  library("checkpoint") # https://cran.r-project.org/web/packages/checkpoint/index.html
} else {
  install.packages("checkpoint")
  suppressPackageStartupMessages(library("checkpoint"))
  suppressPackageStartupMessages(checkpoint("2021-04-20"))  # all packages in your project will be taken from that date.
}
if ("DESeq2" %in% installed.packages()){
  library("DESeq2")
} else {
  BiocManager::install("DESeq2")
  library("DESeq2")
}
if ("dplyr" %in% installed.packages()){
  library("dplyr")
} else {
  install.packages("dplyr")
  library("dplyr")
}
if ("tidyr" %in% installed.packages()){
  library("tidyr")
} else {
  install.packages("tidyr")
  library("tidyr")
}
if ("tidyverse" %in% installed.packages()){
  library("tidyverse")
} else {
  install.packages("tidyverse")
  library("tidyverse")
}
if ("Biostrings" %in% installed.packages()){
  library("Biostrings") 
} else {
  BiocManager::install("Biostrings")
  library("Biostrings")
}
if ("biomaRt" %in% installed.packages()){
  library("biomaRt") 
} else {
  BiocManager::install("biomaRt")
  library("biomaRt")
}
if ("biomartr" %in% installed.packages()){
  library("biomartr")
} else {
  install.packages("biomartr", dependencies = TRUE)
  library("biomartr")
}
if ("clusterProfiler" %in% installed.packages()){
  library("clusterProfiler") 
} else {
  BiocManager::install("clusterProfiler")
  library("clusterProfiler")
}
if ("org.At.tair.db" %in% installed.packages()){
  library("org.At.tair.db") 
} else {
  BiocManager::install("org.At.tair.db")
  library("org.At.tair.db")
}
if ("tibble" %in% installed.packages()){
  library("tibble") 
} else {
  install.packages("tibble")
  library("tibble")
}
if ("mixOmics" %in% installed.packages()){
  library("mixOmics") 
} else {
  BiocManager::install("mixOmics")
  library("mixOmics")
}
if ("vegan" %in% installed.packages()){
  library("vegan") 
} else {
  install.packages("vegan")
  library("vegan")
}
if ("apeglm" %in% installed.packages()){
  library("apeglm") 
} else {
  BiocManager::install("apeglm")
  library("apeglm")
}
if ("EnhancedVolcano" %in% installed.packages()){
  library("EnhancedVolcano") 
} else {
  BiocManager::install("EnhancedVolcano")
  library("EnhancedVolcano")
}
if ("patchwork" %in% installed.packages()){
  library("patchwork") 
} else {
  BiocManager::install("patchwork")
  library("patchwork")
}
if ("reshape" %in% installed.packages()){
  library("reshape") 
} else {
  install.packages("reshape")
  library("reshape")
}
```

# PCA analysis

Load the function:
```{r}
source("Ath2/scripts/create_pca_plot.R")
```

Run the function with default settings, which is
```{r, eval = FALSE}
plot_pca <- function(count_csv_file = "Ath2/inputs/counts.csv",
                     xp_design_csv_file = "~Ath2/inputs/xp_design.csv",
                     pc_x_axis = "PC1", 
                     pc_y_axis = "PC2",
                     trm = c("a","b","c","d","e","f","g"),
                     pca_colour = "solA")
```

```{r}
plot_pca()
```

In order to make an overview of what determines the clustering, make the same plot with different colour guides and group them together with patchwork package
```{r}
p1 <- plot_pca(pca_colour = "treatment")
p2 <- plot_pca()
p3 <- plot_pca(pca_colour = "N")
p4 <- plot_pca(pca_colour = "P")

(p1 | p2) / (p3 | p4)
```

This figure is saved as PCAplot_PC1PC2_allsamples.jpeg

There is no good separation based on treatment or solA supply. Therefore, check also PC3 and PC4
```{r}
p1 <- plot_pca(pc_x_axis = "PC3", pc_y_axis = "PC4", pca_colour = "treatment")
p2 <- plot_pca(pc_x_axis = "PC3", pc_y_axis = "PC4")
p3 <- plot_pca(pc_x_axis = "PC3", pc_y_axis = "PC4", pca_colour = "N")
p4 <- plot_pca(pc_x_axis = "PC3", pc_y_axis = "PC4", pca_colour = "P")

(p1 | p2) / (p3 | p4)
```

This figure is saved as PCAplot_PC3PC4_allsamples.jpeg

Check the screeplot of all the treatments.

```{r}
source("Ath2/scripts/scree_plot.R")
plot_scree()
```

Check the histograms of count variability per sample before and after filtering:

```{r}
source("Ath2/scripts/produce_scaled_counts_matrix.R")
scaled_counts <- produce_scaled_counts_matrix()

source("Ath2/scripts/filter_counts_based_on_treatment.R")
f <- filter_counts_based_on_treatment()
ft <- f %>% t() %>% as.data.frame() %>% gather ()
ggplot(ft, aes(value)) + 
  geom_histogram(bins = 10) + 
  facet_wrap(~key, scales = 'free_x') +
  scale_y_log10()

f_no_0 <- f[vapply(f, 
                   function(z) length(unique(z)) > 1,
                   logical(1L))] %>% data.matrix(., rownames.force = T)

median_all_genes <- median(f_no_0)
median_per_gene <- apply(f_no_0, 2, median)
f_no_0_t <- f_no_0 %>% t() %>% as.data.frame()
f_f <- f_no_0_t %>% filter(median_per_gene > median_all_genes) %>% t() %>% as.data.frame()

f_ft <- f_f %>% t() %>% as.data.frame() %>% gather()
head(f_ft)
ggplot(f_ft, aes(value)) + 
  geom_histogram(bins = 10) + 
  facet_wrap(~key, scales = 'free_x') +
  scale_y_log10() 

```

These two histograms are saved as histogram_counts_beforefilter.jpeg and histogram_counts_afterfilter.jpeg.

However, this experiment is based on pair-wise comparisons. We have different nutritional conditions (no starvation, only P starvation, N+P starvation) and within these conditions we compare the effect of adding solA. There could be an effect of solA in one condition, but not in the others. Therefore, it makes sense to look whether samples within conditions cluster based on solA treatment.
```{r}
p1 <- plot_pca(trm = c("a","b")) + ggtitle("No starvation")
p2 <- plot_pca(pc_x_axis = "PC3", pc_y_axis = "PC4", trm = c("c","d")) + ggtitle("Only P starvation")
p3 <- plot_pca(trm = c("e","f")) + ggtitle("N+P starvation")

p1 + p2 + p3 + plot_layout(ncol = 2)
```

This plot was saved as PCAplots_showing_clustering_solA.jpeg
In these plots, the clustering based on solA treatment is better.

Check scree plot of all nutritional conditions.
```{r}
p1 <- plot_scree(trm = c("a","b")) + ggtitle("No starvation")
p2 <- plot_scree(trm = c("c","d")) + ggtitle("Only P starvation")
p3 <- plot_scree(trm = c("e","f")) + ggtitle("N+P starvation")

p1 + p2 + p3 + plot_layout(ncol = 2)
```


# DEG analysis

## Wald test

Taking into account all samples, regardless of nutritional condition, check the amount of DEGs comparing solA yes vs no. The design of the DESeq formula is set to ~ N + P + solA
```{r}
source("Ath2/scripts/volcanoplot.R")
```
```{r, warning = FALSE, message = FALSE}
make_volcanoplot(trtm = c("a","b","c","d","e","f","g"), log2FC_threshold = 0, FCcutoff_volcano = 1, padj_threshold = 0.05, ttl = "All treatments, solA treatment, Wald", method = "solA", xsize = 2.5)
```

There are a few significant genes present.

Also do this analysis for the within nutritional condition comparison. In this case, the design formula is set to ~ treatment (N and P are not relevant anymore - will even give an error - because you compare samples that have the same N and P)
```{r, warning = FALSE, message = FALSE}
make_volcanoplot(log2FC_threshold = 0, FCcutoff_volcano = 1, padj_threshold = 0.05, xsize = 1.5, ttl = "No starvation, solA treatment")
make_volcanoplot(trtm = c("c", "d"), ref_treatment = "d", treatment2 = "c", log2FC_threshold = 0, FCcutoff_volcano = 1, padj_threshold = 0.05, xsize = 1.5, ttl = "P starvation, +N, solA treatment")
make_volcanoplot(trtm = c("e", "f"), ref_treatment = "f", treatment2 = "e", log2FC_threshold = 0, FCcutoff_volcano = 1, padj_threshold = 0.05, xsize = 1.5, ttl = "N+P starvation, solA treatment")
```


## Likelihood Ratio Test (LRT)

Let's compare the DEGs from the Wald test with the LRT (Likelihood Ratio Test) for verification.To start with, let's take into account all samples and see if LRT detects any DEGs based on solA treatment.
```{r}
source("Ath2/scripts/compare_Wald_vs_LRT.R")
```

The output table of this function gives all the genes that overlap between the Wald test and LRT. So the number of rows is the number of overlapping genes.The formulae for the LRT are ~N + P (null model) and ~N + P + solA (full model), because we select method = "solA". This same full model is used for Wald test.
```{r, warning = FALSE, message = FALSE}
compare_wald_vs_LRT(trtm = c("a","b","c","d","e","f","g"), method = "solA")
```

Let's do the same for the pairwise comparisons within the nutritional conditions. The formulae for the LRT are ~1 (null model) and ~treatment (full model), because we select method = "treatment". This same full model is used for the Wald test.
```{r, warning = FALSE, message = FALSE}
#for no starvation:
compare_wald_vs_LRT(trtm = c("a","b"), method = "treatment")
#for only P starvation:
compare_wald_vs_LRT(trtm = c("c","d"), ref_treatment = "c", treatment2 = "d", method = "treatment")
#for N+P starvation:
compare_wald_vs_LRT(trtm = c("e","f"), ref_treatment = "e", treatment2 = "f", method = "treatment")
```

Let's visualise these results in a bar plot:

```{r}
samples <- c("all samples","no starvation","only P starvation","N+P starvation")
Wald <- c(630,77,45,395)
LRT <- c(612,76,46,355)
overlap <- c(604,76,45,355)
x <- data.frame(samples, Wald, LRT, overlap)
x <- melt(x)
ggplot(data = x,
       aes(x = samples, y = value, fill = variable)) +
  geom_bar(position = "dodge",
           stat = "identity") +
  ggtitle("DEGs by solA treatment, different sample subgroups") +
  xlab("") +
  ylab("# DEGs") + 
  theme_minimal() +
  scale_fill_manual(values = c("goldenrod3","sienna3","dodgerblue3")) +
  coord_flip() +
  geom_text(aes(label=value), 
            position = position_dodge(width = 0.9), 
            vjust = 0.3, 
            hjust = 1.2,
            color="white", 
            size=3.5)
```

# Annotation of DEGs

Start with annotating the list of DEGs of each subset.
```{r}
source("Ath2/scripts/get_annotated_DEGs.R")
```

The .csv file will be written to Ath2/outputs/annotated_DEGslist.csv
```{r message=FALSE, warning=FALSE}
x <- get_annotated_DEGs(trtm = c("a","b","c","d","e","f","g"), method = "solA")
head(x)
```

Then, let's see if there are any GO terms enriched for these genes. The .csv file with all GO terms will be written to Ath2/outputs/GOannotationslist.csv
```{r}
source("Ath2/scripts/GO_annotation_list.R")
```
```{r message=FALSE, warning=FALSE}
GO_annotation_list(trtm = c("a","b","c","d","e","f","g"), method = "solA", plottype = "bar")
```

It is also possible to see the relationships between GO terms that are enriched:
```{r message=FALSE, warning=FALSE}
GO_annotation_list(trtm = c("a","b","c","d","e","f","g"), method = "solA", plottype = "go")
```
